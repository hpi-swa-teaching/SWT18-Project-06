Notification subclass: #ProgressInitiationException	instanceVariableNames: 'workBlock maxVal minVal aPoint progressTitle'	classVariableNames: 'PreferredProgressBarPosition'	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!ProgressInitiationException commentStamp: '<historical>' prior: 0!I provide a way to alter the behavior of the old-style progress notifier in String. See examples in:ProgressInitiationException testWithout.ProgressInitiationException testWith.!!ProgressInitiationException methodsFor: '*Etoys-Squeakland-as yet unclassified' stamp: 'yo 9/18/2006 21:38'!defaultMorphicAction	| result progress |	progress := SystemProgressMorph label: progressTitle min: minVal max: maxVal.	[result := workBlock value: progress] ensure: [SystemProgressMorph close: progress].	self resume: result! !!ProgressInitiationException methodsFor: '*Etoys-Squeakland-as yet unclassified' stamp: 'tak 9/6/2006 12:02'!suppressFileInProgressBar	self signalerContext sender method = (PositionableStream >> #fileInAnnouncing:)		ifTrue: [self				sendNotificationsTo: [:min :max :curr | curr]]		ifFalse: [self pass]! !!ProgressInitiationException methodsFor: 'handling' stamp: 'cmm 10/17/2011 23:10'!defaultAction	self resume! !!ProgressInitiationException methodsFor: 'handling' stamp: 'cmm 10/17/2011 23:10'!defaultResumeValue	^ UIManager default		displayProgress: progressTitle		at: aPoint		from: minVal		to: maxVal		during: workBlock! !!ProgressInitiationException methodsFor: 'initialize-release' stamp: 'RAA 5/15/2000 11:43'!display: argString at: argPoint from: argMinVal to: argMaxVal during: argWorkBlock	progressTitle := argString.	aPoint := argPoint.	minVal := argMinVal.	maxVal := argMaxVal.	workBlock := argWorkBlock.	^self signal! !!ProgressInitiationException methodsFor: 'initialize-release' stamp: 'RAA 5/15/2000 12:40'!sendNotificationsTo: aNewBlock	self resume: (		workBlock value: [ :barVal |			aNewBlock value: minVal value: maxVal value: barVal		]	)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ProgressInitiationException class	instanceVariableNames: ''!!ProgressInitiationException class methodsFor: '*Etoys-Squeakland-signalling' stamp: 'tak 9/6/2006 10:43'!display: aString during: workBlock 	"Show progress bar; the position should be standardize from 0 to 1"	"ProgressInitiationException display: 'progress' during: [:bar | 		0 to: 1 by: 0.1 do: [:x | bar value: x.			(Delay forMilliseconds: 100) wait]]"	^ self new		display: aString		at: Sensor cursorPoint		from: 0		to: 1		during: workBlock! !!ProgressInitiationException class methodsFor: 'accessing' stamp: 'cmm 6/15/2011 14:52'!preferredProgressBarPoint	^ self preferredProgressBarPosition = #cursorPoint		ifTrue: [ Sensor cursorPoint ]		ifFalse: [ UIManager default screenBounds perform: self preferredProgressBarPosition ]! !!ProgressInitiationException class methodsFor: 'accessing' stamp: 'cmm 6/14/2011 22:19'!preferredProgressBarPosition	^ PreferredProgressBarPosition ifNil: [ #center ]! !!ProgressInitiationException class methodsFor: 'accessing' stamp: 'cmm 6/15/2011 10:39'!preferredProgressBarPosition: aSymbol 	"Specify any of:  #center, #topCenter, #bottomCenter, #leftCenter, #rightCenter, #topLeft, #topRight, #bottomLeft or #bottomRight or #cursorPoint."	^ PreferredProgressBarPosition! !!ProgressInitiationException class methodsFor: 'examples and tests' stamp: 'cmm 6/15/2011 10:57'!testInnermost	"test the progress code WITHOUT special handling"	^'Now here''s some Real Progress'		displayProgressFrom: 0 		to: 10		during: [ :bar |			1 to: 10 do: [ :x | 				bar value: x. (Delay forMilliseconds: 500) wait.				x = 5 ifTrue: [1/0].	"just to make life interesting"			].			'done'		].! !!ProgressInitiationException class methodsFor: 'examples and tests' stamp: 'RAA 5/15/2000 12:42'!testWith	"test progress code WITH special handling of progress notifications"	^[ self testWithAdditionalInfo ] 		on: ProgressInitiationException		do: [ :ex | 			ex sendNotificationsTo: [ :min :max :curr |				Transcript show: min printString,'  ',max printString,'  ',curr printString; cr			].		].! !!ProgressInitiationException class methodsFor: 'examples and tests' stamp: 'RAA 5/15/2000 12:04'!testWithAdditionalInfo	^{'starting'. self testWithout. 'really!!'}! !!ProgressInitiationException class methodsFor: 'examples and tests' stamp: 'RAA 5/15/2000 15:45'!testWithout	"test the progress code WITHOUT special handling"	^[self testInnermost]		on: ZeroDivide		do: [ :ex | ex resume]! !!ProgressInitiationException class methodsFor: 'signalling' stamp: 'cmm 6/14/2011 22:17'!display: aString at: aPoint from: minVal to: maxVal during: workBlock 	^ self new		display: aString		at: (aPoint ifNil: [ self preferredProgressBarPoint ])		from: minVal		to: maxVal		during: workBlock! !!ProgressInitiationException class methodsFor: 'signalling' stamp: 'cmm 6/14/2011 19:15'!display: aString from: minVal to: maxVal during: workBlock 	^ self		display: aString		at: nil		from: minVal		to: maxVal		during: workBlock! !Object subclass: #ToolBuilder	instanceVariableNames: 'parent'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!ToolBuilder commentStamp: '<historical>' prior: 0!I am a tool builder, that is an object which knows how to create concrete widgets from abstract specifications. Those specifications are used by tools which want to be able to function in diverse user interface paradigms, such as MVC, Morphic, Tweak, wxWidgets etc.The following five specs must be supported by all implementations:	* PluggableButton	* PluggableList	* PluggableText	* PluggablePanel	* PluggableWindowThe following specs are optional:	* PluggableTree: If not supported, the tool builder must answer nil when asked for a pluggableTreeSpec. Substitution will require client support so clients must be aware that some tool builders may not support trees (MVC for example, or Seaside). See examples in FileListPlus or TestRunnerPlus.	* PluggableMultiSelectionList: If multi-selection lists are not supported, tool builder will silently support regular single selection lists.	* PluggableInputField: Intended as a HINT for the builder that this widget will be used as a single line input field. Unless explicitly supported it will be automatically substituted by PluggableText.	* PluggableActionButton: Intended as a HINT for the builder that this widget will be used as push (action) button. Unless explicitly supported it will be automatically substituted by PluggableButton.	* PluggableRadioButton: Intended as a HINT for the builder that this widget will be used as radio button. Unless explicitly supported it will be automatically substituted by PluggableButton.	* PluggableCheckBox: Intended as a HINT for the builder that this widget will be used as check box. Unless explicitly supported it will be automatically substituted by PluggableButton.!!ToolBuilder methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:54'!parent	^parent! !!ToolBuilder methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:54'!parent: aWidget	parent := aWidget! !!ToolBuilder methodsFor: 'accessing' stamp: 'ar 7/14/2005 22:23'!widgetAt: widgetID	"Answer the widget with the given ID"	^self widgetAt: widgetID ifAbsent:[nil]! !!ToolBuilder methodsFor: 'accessing' stamp: 'ar 7/14/2005 22:23'!widgetAt: widgetID ifAbsent: aBlock	"Answer the widget with the given ID"	^aBlock value! !!ToolBuilder methodsFor: 'building' stamp: 'ar 6/5/2005 12:35'!buildAll: aList in: newParent	"Build the given set of widgets in the new parent"	| prior |	aList ifNil:[^self].	prior := parent.	parent := newParent.	aList do:[:each| each buildWith: self].	parent := prior.! !!ToolBuilder methodsFor: 'building' stamp: 'ar 6/5/2005 12:35'!build: anObject	"Build the given object using this tool builder"	^anObject buildWith: self! !!ToolBuilder methodsFor: 'defaults' stamp: 'ar 2/12/2005 14:18'!pluggableActionButtonSpec	^PluggableActionButtonSpec! !!ToolBuilder methodsFor: 'defaults' stamp: 'cmm 2/19/2010 14:29'!pluggableAlternateMultiSelectionListSpec	^ PluggableAlternateMultiSelectionListSpec! !!ToolBuilder methodsFor: 'defaults' stamp: 'ar 2/10/2005 00:31'!pluggableButtonSpec	^PluggableButtonSpec! !!ToolBuilder methodsFor: 'defaults' stamp: 'ar 2/12/2005 14:18'!pluggableCheckBoxSpec	^PluggableCheckBoxSpec! !!ToolBuilder methodsFor: 'defaults' stamp: 'ar 8/18/2009 00:03'!pluggableCodePaneSpec	^PluggableCodePaneSpec! !!ToolBuilder methodsFor: 'defaults' stamp: 'mt 7/14/2016 08:47'!pluggableDialogSpec	^PluggableDialogSpec! !!ToolBuilder methodsFor: 'defaults' stamp: 'rww 9/11/2010 14:09'!pluggableDropDownListSpec	^PluggableDropDownListSpec! !!ToolBuilder methodsFor: 'defaults' stamp: 'ar 2/11/2005 16:41'!pluggableInputFieldSpec	^PluggableInputFieldSpec! !!ToolBuilder methodsFor: 'defaults' stamp: 'ar 2/10/2005 00:30'!pluggableListSpec	^PluggableListSpec! !!ToolBuilder methodsFor: 'defaults' stamp: 'cwp 6/8/2005 23:24'!pluggableMenuSpec	^ PluggableMenuSpec! !!ToolBuilder methodsFor: 'defaults' stamp: 'tpr 11/7/2017 10:07'!pluggableMultiColumnListSpec	^PluggableMultiColumnListSpec! !!ToolBuilder methodsFor: 'defaults' stamp: 'ar 2/12/2005 13:43'!pluggableMultiSelectionListSpec	^PluggableMultiSelectionListSpec! !!ToolBuilder methodsFor: 'defaults' stamp: 'ar 2/10/2005 00:30'!pluggablePanelSpec	^PluggablePanelSpec! !!ToolBuilder methodsFor: 'defaults' stamp: 'pascal 5/13/2018 12:28'!pluggablePasteUpMorphSpec	^PluggablePasteUpMorphSpec! !!ToolBuilder methodsFor: 'defaults' stamp: 'ar 2/12/2005 14:18'!pluggableRadioButtonSpec	^PluggableRadioButtonSpec! !!ToolBuilder methodsFor: 'defaults' stamp: 'mt 6/15/2014 07:47:54.023'!pluggableScrollPaneSpec	^ PluggableScrollPaneSpec! !!ToolBuilder methodsFor: 'defaults' stamp: 'mt 5/3/2015 14:58'!pluggableSpacerSpec	^ PluggableSpacerSpec! !!ToolBuilder methodsFor: 'defaults' stamp: 'ar 2/10/2005 00:31'!pluggableTextSpec	^PluggableTextSpec! !!ToolBuilder methodsFor: 'defaults' stamp: 'ar 2/12/2005 16:53'!pluggableTreeSpec	^PluggableTreeSpec! !!ToolBuilder methodsFor: 'defaults' stamp: 'ar 2/10/2005 00:30'!pluggableWindowSpec	^PluggableWindowSpec! !!ToolBuilder methodsFor: 'initialize' stamp: 'ar 2/9/2005 19:49'!initialize! !!ToolBuilder methodsFor: 'opening' stamp: 'ar 6/5/2005 12:37'!close: aWidget	"Close a previously opened widget"	^self subclassResponsibility! !!ToolBuilder methodsFor: 'opening' stamp: 'ar 6/5/2005 12:38'!open: anObject	"Build and open the object. Answer the widget opened."	^self subclassResponsibility! !!ToolBuilder methodsFor: 'opening' stamp: 'ar 6/5/2005 12:38'!open: anObject label: aString	"Build an open the object, labeling it appropriately.  Answer the widget opened."	^self subclassResponsibility! !!ToolBuilder methodsFor: 'opening' stamp: 'dtl 9/11/2010 18:56'!openDebugger: aSpec	"Build and open a debugger from the given spec.	Answer the widget opened. Subclasses can override this	method if opening a debugger has specific requirements	different from opening other widgets." 	self open: aSpec! !!ToolBuilder methodsFor: 'opening' stamp: 'eem 10/6/2014 12:36'!openDebugger: aSpec label: aString	"Build and open a debugger from the given spec, labeling it appropriately.	Answer the widget opened. Subclasses can override this	method if opening a debugger has specific requirements	different from opening other widgets." 	^self open: aSpec label: aString! !!ToolBuilder methodsFor: 'opening' stamp: 'dtl 5/27/2013 14:53'!openDebugger: aSpec label: aString closing: topView	"Build and open a debugger from the given spec, labeling it appropriately.	Answer the widget opened. Subclasses can override this	method if opening a debugger has specific requirements	different from opening other widgets." 	self close: topView.	self open: aSpec label: aString! !!ToolBuilder methodsFor: 'opening' stamp: 'ar 6/5/2005 12:39'!runModal: aWidget	"Run the (previously opened) widget modally, e.g., 	do not return control to the sender before the user has responded."	^self subclassResponsibility! !!ToolBuilder methodsFor: 'widgets optional' stamp: 'pascal 5/13/2018 12:27'!buildPasteUpMorph: aSpec	|widget|		widget := PasteUpMorph new.	self register: widget id: aSpec name.
	self setFrame: aSpec frame in: widget.	parent ifNotNil:[self add: widget to: parent].		^widget! !!ToolBuilder methodsFor: 'widgets optional' stamp: 'ar 2/12/2005 14:05'!buildPluggableActionButton: spec	^self buildPluggableButton: spec! !!ToolBuilder methodsFor: 'widgets optional' stamp: 'mt 4/12/2015 18:23'!buildPluggableAlternateMultiSelectionList: aSpec		^ self buildPluggableList: aSpec! !!ToolBuilder methodsFor: 'widgets optional' stamp: 'ar 2/12/2005 14:05'!buildPluggableCheckBox: spec	^self buildPluggableButton: spec! !!ToolBuilder methodsFor: 'widgets optional' stamp: 'ar 8/18/2009 00:04'!buildPluggableCodePane: aSpec	^self buildPluggableText: aSpec! !!ToolBuilder methodsFor: 'widgets optional' stamp: 'mt 7/13/2016 16:37'!buildPluggableDialog: spec	| windowSpec |	windowSpec := self pluggableWindowSpec new.	windowSpec children: (spec children ifNil: [OrderedCollection new]).		"TODO: Convert the dialog's message into some element in the children."			spec buttons ifNotNil: [:buttons | windowSpec children addAll: buttons].	windowSpec		model: spec model;		extent: spec extent;		label: spec title.	^ self buildPluggableWindow: windowSpec! !!ToolBuilder methodsFor: 'widgets optional' stamp: 'rww 9/11/2010 13:37'!buildPluggableDropDownList: spec	^self buildPluggableList: spec! !!ToolBuilder methodsFor: 'widgets optional' stamp: 'ar 2/12/2005 18:39'!buildPluggableInputField: aSpec	^self buildPluggableText: aSpec! !!ToolBuilder methodsFor: 'widgets optional' stamp: 'ar 2/12/2005 14:06'!buildPluggableMultiSelectionList: aSpec	^self buildPluggableList: aSpec! !!ToolBuilder methodsFor: 'widgets optional' stamp: 'ar 2/12/2005 14:05'!buildPluggableRadioButton: spec	^self buildPluggableButton: spec! !!ToolBuilder methodsFor: 'widgets optional' stamp: 'mt 6/15/2014 08:09:41.581'!buildPluggableScrollPane: spec	^ spec children		ifNotNil: [self buildPluggablePanel: spec]		ifNil: [spec morph ifNil: [spec morphClass new]]! !!ToolBuilder methodsFor: 'widgets required' stamp: 'ar 2/9/2005 18:46'!buildPluggableButton: aSpec	^self subclassResponsibility! !!ToolBuilder methodsFor: 'widgets required' stamp: 'ar 2/9/2005 18:47'!buildPluggableList: aSpec	^self subclassResponsibility! !!ToolBuilder methodsFor: 'widgets required' stamp: 'mt 4/12/2015 20:47'!buildPluggableMenu: menuSpec 	self subclassResponsibility.! !!ToolBuilder methodsFor: 'widgets required' stamp: 'mt 4/12/2015 20:47'!buildPluggableMenuItem: menuSpec 	self subclassResponsibility.! !!ToolBuilder methodsFor: 'widgets required' stamp: 'tpr 11/7/2017 10:03'!buildPluggableMultiColumnList: aSpec	^self subclassResponsibility! !!ToolBuilder methodsFor: 'widgets required' stamp: 'ar 6/5/2005 12:30'!buildPluggablePanel: aSpec	^self subclassResponsibility! !!ToolBuilder methodsFor: 'widgets required' stamp: 'mt 5/3/2015 14:47'!buildPluggableSpacer: aSpec	^ self subclassResponsibility! !!ToolBuilder methodsFor: 'widgets required' stamp: 'ar 2/9/2005 18:47'!buildPluggableText: aSpec	^self subclassResponsibility! !!ToolBuilder methodsFor: 'widgets required' stamp: 'ar 2/12/2005 00:36'!buildPluggableTree: aSpec	^self subclassResponsibility! !!ToolBuilder methodsFor: 'widgets required' stamp: 'ar 2/9/2005 18:47'!buildPluggableWindow: aSpec	^self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ToolBuilder class	instanceVariableNames: ''!!ToolBuilder class methodsFor: 'accessing' stamp: 'tpr 1/29/2018 11:41'!default	"Answer the default tool builder"	^ Project uiManager toolBuilder! !!ToolBuilder class methodsFor: 'accessing' stamp: 'dtl 3/21/2015 11:40'!findDefault	"Answer a default tool builder"	| builderClass |	"Note: The way the following is phrased ensures that you can always make 'more specific' builders merely by subclassing a tool builder and implementing a more specific way of reacting to #isActiveBuilder. For example, a BobsUIToolBuilder can subclass MorphicToolBuilder and (if enabled, say Preferences useBobsUITools) will be considered before the parent (generic MorphicToolBuilder)."	builderClass := self allSubclasses 		detect:[:any| any isActiveBuilder and:[			any subclasses noneSatisfy:[:sub| sub isActiveBuilder]]] ifNone:[nil].	builderClass ifNotNil: [^builderClass ].	^self error: 'ToolBuilder not found'! !!ToolBuilder class methodsFor: 'accessing' stamp: 'ar 2/11/2005 15:23'!isActiveBuilder	"Answer whether I am the currently active builder"	^false! !!ToolBuilder class methodsFor: 'instance creation' stamp: 'KR 4/28/2006 21:05'!build: aClass	^self default build: aClass! !!ToolBuilder class methodsFor: 'instance creation' stamp: 'ar 2/11/2005 18:15'!open: aClass	^self default open: aClass! !!ToolBuilder class methodsFor: 'instance creation' stamp: 'ar 2/11/2005 18:15'!open: aClass label: aString	^self default open: aClass label: aString! !!ToolBuilder class methodsFor: 'services' stamp: 'mt 5/4/2016 13:15'!getBoundsForWindow: window	"Return the bounds for the given window."	self subclassResponsibility.! !!ToolBuilder class methodsFor: 'services' stamp: 'mt 5/4/2016 13:20'!setBoundsForWindow: window to: rectangle	"Set the bounds for the given window."	self subclassResponsibility.! !Object subclass: #ToolBuilderSpec	instanceVariableNames: 'name help'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!ToolBuilderSpec commentStamp: 'ar 2/11/2005 14:59' prior: 0!I am an abstract widget specification. I can be rendered using many different UI frameworks.!!ToolBuilderSpec methodsFor: 'accessing' stamp: 'btr 11/26/2006 12:37'!help	"Answer the message to get the help texts of this element."	^ help! !!ToolBuilderSpec methodsFor: 'accessing' stamp: 'btr 11/26/2006 12:38'!help: aSymbol 	"Indicate the message to retrieve the help texts of this element."	help := aSymbol! !!ToolBuilderSpec methodsFor: 'accessing' stamp: 'cwp 4/25/2005 03:42'!name	^ name! !!ToolBuilderSpec methodsFor: 'accessing' stamp: 'cwp 4/25/2005 03:40'!name: anObject	name := anObject! !!ToolBuilderSpec methodsFor: 'building' stamp: 'ar 2/12/2005 18:17'!buildWith: aBuilder	^self subclassResponsibility! !ToolBuilderSpec subclass: #PluggableMenuItemSpec	instanceVariableNames: 'label action checked enabled separator subMenu checkable'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableMenuItemSpec methodsFor: 'accessing' stamp: 'ar 2/28/2006 17:23'!action	"Answer the action associated with the receiver"	^action! !!PluggableMenuItemSpec methodsFor: 'accessing' stamp: 'ar 2/28/2006 17:23'!action: aMessageSend	"Answer the action associated with the receiver"	action := aMessageSend! !!PluggableMenuItemSpec methodsFor: 'accessing' stamp: 'fbs 6/18/2013 17:27'!beCheckable	checkable := true.! !!PluggableMenuItemSpec methodsFor: 'accessing' stamp: 'ar 2/28/2006 17:28'!checked	"Answer whether the receiver is checked"	^checked ifNil:[false]! !!PluggableMenuItemSpec methodsFor: 'accessing' stamp: 'ar 2/28/2006 17:21'!checked: aBool	"Indicate whether the receiver is checked"	checked := aBool.! !!PluggableMenuItemSpec methodsFor: 'accessing' stamp: 'ar 2/28/2006 17:28'!enabled	"Answer whether the receiver is enabled"	^enabled ifNil:[true]! !!PluggableMenuItemSpec methodsFor: 'accessing' stamp: 'ar 2/28/2006 17:21'!enabled: aBool	"Indicate whether the receiver is enabled"	enabled := aBool! !!PluggableMenuItemSpec methodsFor: 'accessing' stamp: 'fbs 6/18/2013 17:27'!isCheckable	^ checkable! !!PluggableMenuItemSpec methodsFor: 'accessing' stamp: 'ar 2/28/2006 17:20'!label	"Answer the receiver's label"	^label! !!PluggableMenuItemSpec methodsFor: 'accessing' stamp: 'ar 2/28/2006 17:21'!label: aString	"Set the receiver's label"	label := aString! !!PluggableMenuItemSpec methodsFor: 'accessing' stamp: 'ar 2/28/2006 17:28'!separator	"Answer whether the receiver should be followed by a separator"	^separator ifNil:[false]! !!PluggableMenuItemSpec methodsFor: 'accessing' stamp: 'ar 2/28/2006 17:22'!separator: aBool	"Indicate whether the receiver should be followed by a separator"	separator := aBool.! !!PluggableMenuItemSpec methodsFor: 'accessing' stamp: 'ar 2/28/2006 17:22'!subMenu	"Answer the receiver's subMenu"	^subMenu! !!PluggableMenuItemSpec methodsFor: 'accessing' stamp: 'ar 2/28/2006 17:22'!subMenu: aMenuSpec	"Answer the receiver's subMenu"	subMenu := aMenuSpec! !!PluggableMenuItemSpec methodsFor: 'building' stamp: 'ar 2/28/2006 17:23'!buildWith: builder	^ builder buildPluggableMenuItem: self! !!PluggableMenuItemSpec methodsFor: 'initialize' stamp: 'fbs 6/18/2013 17:34'!analyzeLabel	"For Morphic compatiblity. Some labels include markup such as <on>, <off> etc.	Analyze the label for these annotations and take appropriate action."	| marker |	marker := label copyFrom: 1 to: (label indexOf: $>).	(marker = '<on>' or:[marker = '<yes>']) ifTrue:[		checkable := true.		checked := true.		label := label copyFrom: marker size+1 to: label size.	].	(marker = '<off>' or:[marker = '<no>']) ifTrue:[		checkable := true.		checked := false.		label := label copyFrom: marker size+1 to: label size.	].! !!PluggableMenuItemSpec methodsFor: 'initialize' stamp: 'fbs 6/18/2013 17:34'!initialize	checkable := false.! !ToolBuilderSpec subclass: #PluggableMenuSpec	instanceVariableNames: 'label model items'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableMenuSpec methodsFor: 'accessing' stamp: 'ar 2/28/2006 17:27'!items	^ items ifNil: [items := OrderedCollection new]! !!PluggableMenuSpec methodsFor: 'accessing' stamp: 'ar 2/28/2006 17:12'!label	^label! !!PluggableMenuSpec methodsFor: 'accessing' stamp: 'ar 2/28/2006 17:12'!label: aString	label := aString.! !!PluggableMenuSpec methodsFor: 'accessing' stamp: 'cwp 6/8/2005 23:36'!model	^ model! !!PluggableMenuSpec methodsFor: 'accessing' stamp: 'cwp 6/8/2005 23:36'!model: anObject 	model := anObject! !!PluggableMenuSpec methodsFor: 'construction' stamp: 'ar 2/28/2006 17:26'!add: aString action: aMessageSend	| item |	item := self addMenuItem.	item label: aString.	item action: aMessageSend.	^item! !!PluggableMenuSpec methodsFor: 'construction' stamp: 'ar 2/28/2006 17:25'!add: aString target: anObject selector: aSelector argumentList: anArray	^self add: aString action: (MessageSend 				receiver: anObject 				selector: aSelector				arguments: anArray).! !!PluggableMenuSpec methodsFor: 'construction' stamp: 'ar 10/5/2009 21:46'!addList: aList	"Add the given items to this menu, where each item is a pair (<string> <actionSelector>)..  If an element of the list is simply the symobl $-, add a line to the receiver.  The optional third element of each entry, if present, provides balloon help."	aList do: [:tuple |		(tuple == #-)			ifTrue: [self addSeparator]			ifFalse:[ | item |				item := self add: tuple first target: model selector: tuple second argumentList: #().				tuple size > 2 ifTrue:[item help: tuple third]]]! !!PluggableMenuSpec methodsFor: 'construction' stamp: 'ar 2/28/2006 17:27'!addMenuItem	| item |	item := self newMenuItem.	self items add: item.	^item! !!PluggableMenuSpec methodsFor: 'construction' stamp: 'ar 2/28/2006 17:25'!addSeparator	self items isEmpty ifTrue:[^nil].	self items last separator: true.! !!PluggableMenuSpec methodsFor: 'construction' stamp: 'ar 9/7/2009 14:17'!analyzeItemLabels	"Analyze the item labels"	items do:[:item| item analyzeLabel].! !!PluggableMenuSpec methodsFor: 'construction' stamp: 'ar 9/7/2009 14:18'!buildWith: builder	self analyzeItemLabels.	^ builder buildPluggableMenu: self! !!PluggableMenuSpec methodsFor: 'construction' stamp: 'ar 2/28/2006 17:27'!newMenuItem	^PluggableMenuItemSpec new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PluggableMenuSpec class	instanceVariableNames: ''!!PluggableMenuSpec class methodsFor: 'as yet unclassified' stamp: 'cwp 6/9/2005 00:22'!withModel: aModel	^ self new model: aModel! !ToolBuilderSpec subclass: #PluggableWidgetSpec	instanceVariableNames: 'model frame color minimumExtent margin padding horizontalResizing verticalResizing'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableWidgetSpec commentStamp: 'ar 2/9/2005 18:40' prior: 0!The abstract superclass for all widgets.Instance variables:	model	<Object>	The object the various requests should be directed to.	frame	<Rectangle> The associated layout frame for this object (if any).!!PluggableWidgetSpec methodsFor: 'accessing' stamp: 'ar 5/5/2010 22:35'!color	"Answer the selector for retrieving the button's color"	^color! !!PluggableWidgetSpec methodsFor: 'accessing' stamp: 'ar 5/5/2010 22:35'!color: aSymbol	"Indicate the selector for retrieving the button's color"	color := aSymbol! !!PluggableWidgetSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:26'!frame	"Answer the receiver's layout frame"	^frame! !!PluggableWidgetSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:27'!frame: aRectangle	"Indicate the receiver's layout frame"	frame := aRectangle! !!PluggableWidgetSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:28'!model	"Answer the model for which this widget should be built"	^model! !!PluggableWidgetSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:28'!model: aModel	"Indicate the model for which this widget should be built"	model := aModel.! !!PluggableWidgetSpec methodsFor: 'layout hints' stamp: 'mt 5/3/2015 10:13'!horizontalResizing	^ horizontalResizing! !!PluggableWidgetSpec methodsFor: 'layout hints' stamp: 'mt 5/3/2015 10:14'!horizontalResizing: aSymbol	"#rigid, #spaceFill, #shrinkWrap"	horizontalResizing := aSymbol.! !!PluggableWidgetSpec methodsFor: 'layout hints' stamp: 'mt 4/29/2015 16:03'!margin	"Space outside the widgets border.	See: http://www.w3.org/wiki/The_CSS_layout_model_-_boxes_borders_margins_padding"		^ margin! !!PluggableWidgetSpec methodsFor: 'layout hints' stamp: 'mt 4/29/2015 15:59'!margin: numberOrPointOrRectangle	margin := numberOrPointOrRectangle.! !!PluggableWidgetSpec methodsFor: 'layout hints' stamp: 'mt 4/24/2015 10:32'!minimumExtent	^ minimumExtent ifNil: [-1 @ -1]! !!PluggableWidgetSpec methodsFor: 'layout hints' stamp: 'mt 4/24/2015 10:21'!minimumExtent: aPoint	minimumExtent := aPoint.! !!PluggableWidgetSpec methodsFor: 'layout hints' stamp: 'mt 4/24/2015 10:22'!minimumHeight	^ self minimumExtent y! !!PluggableWidgetSpec methodsFor: 'layout hints' stamp: 'mt 4/24/2015 10:22'!minimumHeight: aNumber	self minimumExtent: self minimumExtent x @ aNumber.! !!PluggableWidgetSpec methodsFor: 'layout hints' stamp: 'mt 4/24/2015 10:22'!minimumWidth	^ self minimumExtent x! !!PluggableWidgetSpec methodsFor: 'layout hints' stamp: 'mt 4/24/2015 10:21'!minimumWidth: aNumber	self minimumExtent: aNumber @ self minimumExtent y.! !!PluggableWidgetSpec methodsFor: 'layout hints' stamp: 'mt 4/29/2015 16:02'!padding	"Space inside the widget's border.	See: http://www.w3.org/wiki/The_CSS_layout_model_-_boxes_borders_margins_padding"		^ padding! !!PluggableWidgetSpec methodsFor: 'layout hints' stamp: 'mt 4/29/2015 16:03'!padding: numberOrPointOrRectangle	padding := numberOrPointOrRectangle.! !!PluggableWidgetSpec methodsFor: 'layout hints' stamp: 'mt 5/3/2015 10:13'!verticalResizing	^ verticalResizing! !!PluggableWidgetSpec methodsFor: 'layout hints' stamp: 'mt 5/3/2015 10:14'!verticalResizing: aSymbol	"#rigid, #spaceFill, #shrinkWrap"	verticalResizing := aSymbol.! !PluggableWidgetSpec subclass: #PluggableButtonSpec	instanceVariableNames: 'action label state enabled style changeLabelWhen'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableButtonSpec commentStamp: 'ar 2/11/2005 21:57' prior: 0!A button, both for firing as well as used in radio-button style (e.g., carrying a selection).Instance variables:	action	<Symbol>	The action to perform when the button is fired.	label	<Symbol|String>	The selector for retrieving the button's label or label directly.	state	<Symbol>	The selector for retrieving the button's selection state.	enabled	<Symbo>		The selector for retrieving the button's enabled state.	color	<Symbo>		The selector for retrieving the button color.	help	<String>		The balloon help for the button.!!PluggableButtonSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:20'!action	"Answer the action to be performed by the receiver"	^action! !!PluggableButtonSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:20'!action: aSymbol	"Indicate the action to be performed by the receiver"	action := aSymbol! !!PluggableButtonSpec methodsFor: 'accessing' stamp: 'dtl 9/24/2011 09:06'!changeLabelWhen	"When handled in in an update: handler, treat this symbol as notification	that the button label should be updated."	^changeLabelWhen! !!PluggableButtonSpec methodsFor: 'accessing' stamp: 'dtl 9/24/2011 09:09'!changeLabelWhen: aSymbol	"When the button handles aSymbol in its update: handler, treat it	as notification that the button label should be updated."	changeLabelWhen := aSymbol! !!PluggableButtonSpec methodsFor: 'accessing' stamp: 'ar 6/21/2005 10:41'!enabled	"Answer the selector for retrieving the button's enablement"	^enabled ifNil:[true]! !!PluggableButtonSpec methodsFor: 'accessing' stamp: 'ar 2/11/2005 14:39'!enabled: aSymbol	"Indicate the selector for retrieving the button's enablement"	enabled := aSymbol! !!PluggableButtonSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:18'!label	"Answer the label (or the selector for retrieving the label)"	^label! !!PluggableButtonSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 19:44'!label: aSymbol	"Indicate the selector for retrieving the label"	label := aSymbol.! !!PluggableButtonSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:19'!state	"Answer the selector for retrieving the button's state"	^state! !!PluggableButtonSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 19:44'!state: aSymbol	"Indicate the selector for retrieving the button's state"	state := aSymbol.! !!PluggableButtonSpec methodsFor: 'accessing' stamp: 'dtl 9/24/2011 09:33'!style	"Treat aSymbol as a hint to modify the button appearance."	^style! !!PluggableButtonSpec methodsFor: 'accessing' stamp: 'dtl 9/24/2011 09:25'!style: aSymbol	"Use aSymbol as a hint to modify the button appearance."	style := aSymbol! !!PluggableButtonSpec methodsFor: 'building' stamp: 'ar 2/12/2005 18:16'!buildWith: builder	^builder buildPluggableButton: self! !PluggableButtonSpec subclass: #PluggableActionButtonSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableActionButtonSpec commentStamp: 'dtl 9/19/2011 07:51' prior: 0!PluggableActionButtonSpec is intended as a HINT for the builder that this widget will be used as push (action) button. Unless explicitly supported it will be automatically substituted by PluggableButton.!!PluggableActionButtonSpec methodsFor: 'building' stamp: 'ar 2/12/2005 18:16'!buildWith: builder	^builder buildPluggableActionButton: self! !PluggableButtonSpec subclass: #PluggableCheckBoxSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableCheckBoxSpec commentStamp: 'ar 2/12/2005 23:13' prior: 0!PluggableCheckBox is intended as a HINT for the builder that this widget will be used as check box. Unless explicitly supported it will be automatically substituted by PluggableButton.!!PluggableCheckBoxSpec methodsFor: 'building' stamp: 'ar 2/12/2005 18:16'!buildWith: builder	^builder buildPluggableCheckBox: self! !PluggableWidgetSpec subclass: #PluggableCompositeSpec	instanceVariableNames: 'children layout wantsResizeHandles spacing'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableCompositeSpec commentStamp: 'ar 2/11/2005 21:58' prior: 0!A composite user interface element.Instance variables:	children	<Symbol|Collection>	Symbol to retrieve children or children directly	layout	<Symbol> The layout for this composite.!!PluggableCompositeSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 19:19'!children	"Answer the selector to retrieve this panel's children"	^children! !!PluggableCompositeSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 19:19'!children: aSymbol	"Indicate the selector to retrieve this panel's children"	children := aSymbol! !!PluggableCompositeSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:33'!layout	"Answer the symbol indicating the layout of the composite:		#proportional (default): Use frames as appropriate.		#horizontal: Arrange the elements horizontally		#vertical: Arrange the elements vertically.	"	^layout ifNil:[#proportional]! !!PluggableCompositeSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:17'!layout: aSymbol	"Answer the symbol indicating the layout of the composite:		#proportional (default): Use frames as appropriate.		#horizontal: Arrange the elements horizontally		#vertical: Arrange the elements vertically.	"	layout := aSymbol! !!PluggableCompositeSpec methodsFor: 'accessing' stamp: 'mt 4/29/2015 17:32'!wantsResizeHandles	^ wantsResizeHandles! !!PluggableCompositeSpec methodsFor: 'accessing' stamp: 'mt 4/28/2015 13:17'!wantsResizeHandles: aBoolean	wantsResizeHandles := aBoolean.! !!PluggableCompositeSpec methodsFor: 'layout hints' stamp: 'mt 4/29/2015 15:54'!spacing	"...between components of this widget."		^ spacing! !!PluggableCompositeSpec methodsFor: 'layout hints' stamp: 'mt 4/29/2015 15:54'!spacing: numberOrPoint	spacing := numberOrPoint.! !PluggableCompositeSpec subclass: #PluggableDialogSpec	instanceVariableNames: 'title message extent buttons closeAction exclusive autoCancel'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableDialogSpec methodsFor: 'accessing' stamp: 'mt 1/17/2018 08:46'!autoCancel	"Automatically cancel the dialog if the user clicks outside its bounds."		^ autoCancel! !!PluggableDialogSpec methodsFor: 'accessing' stamp: 'mt 8/5/2016 09:44'!autoCancel: aBoolean	autoCancel := aBoolean.! !!PluggableDialogSpec methodsFor: 'accessing' stamp: 'mt 7/13/2016 16:31'!buttons	^ buttons! !!PluggableDialogSpec methodsFor: 'accessing' stamp: 'mt 7/13/2016 16:31'!buttons: anObject	buttons := anObject! !!PluggableDialogSpec methodsFor: 'accessing' stamp: 'mt 7/14/2016 08:24'!closeAction	^ closeAction! !!PluggableDialogSpec methodsFor: 'accessing' stamp: 'mt 7/14/2016 08:24'!closeAction: anObject	closeAction := anObject! !!PluggableDialogSpec methodsFor: 'accessing' stamp: 'mt 8/5/2016 09:44'!exclusive	^ exclusive! !!PluggableDialogSpec methodsFor: 'accessing' stamp: 'mt 8/5/2016 09:44'!exclusive: aBoolean	exclusive := aBoolean.! !!PluggableDialogSpec methodsFor: 'accessing' stamp: 'mt 7/13/2016 16:31'!extent	^ extent! !!PluggableDialogSpec methodsFor: 'accessing' stamp: 'mt 7/13/2016 16:31'!extent: anObject	extent := anObject! !!PluggableDialogSpec methodsFor: 'accessing' stamp: 'mt 7/13/2016 16:31'!message	^ message! !!PluggableDialogSpec methodsFor: 'accessing' stamp: 'mt 7/13/2016 16:31'!message: anObject	message := anObject! !!PluggableDialogSpec methodsFor: 'accessing' stamp: 'mt 7/13/2016 16:31'!title	^ title! !!PluggableDialogSpec methodsFor: 'accessing' stamp: 'mt 7/13/2016 16:31'!title: anObject	title := anObject! !!PluggableDialogSpec methodsFor: 'building' stamp: 'mt 7/14/2016 09:42'!buildWith: builder	^builder buildPluggableDialog: self.! !!PluggableDialogSpec methodsFor: 'layout hints' stamp: 'mt 7/14/2016 16:24'!horizontalResizing	^ #rigid! !!PluggableDialogSpec methodsFor: 'layout hints' stamp: 'mt 7/14/2016 16:24'!verticalResizing	^ #rigid! !!PluggableDialogSpec methodsFor: 'window compatibility' stamp: 'mt 7/14/2016 08:42'!label	^ self title! !!PluggableDialogSpec methodsFor: 'window compatibility' stamp: 'mt 7/14/2016 08:43'!label: stringOrSymbol	self title: stringOrSymbol.! !PluggableWidgetSpec subclass: #PluggableDropDownListSpec	instanceVariableNames: 'listSelector selectionSelector selectionSetter'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableDropDownListSpec methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:36'!listSelector	"Answer the value of listSelector"	^ listSelector! !!PluggableDropDownListSpec methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:36'!listSelector: anObject	"Set the value of listSelector"	listSelector := anObject! !!PluggableDropDownListSpec methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:36'!selectionSelector	"Answer the value of selectionSelector"	^ selectionSelector! !!PluggableDropDownListSpec methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:36'!selectionSelector: anObject	"Set the value of selectionSelector"	selectionSelector := anObject! !!PluggableDropDownListSpec methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:36'!selectionSetter	"Answer the value of selectionSetter"	^ selectionSetter! !!PluggableDropDownListSpec methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:36'!selectionSetter: anObject	"Set the value of selectionSetter"	selectionSetter := anObject! !!PluggableDropDownListSpec methodsFor: 'building' stamp: 'rww 9/11/2010 13:36'!buildWith: builder	^builder buildPluggableDropDownList: self! !PluggableWidgetSpec subclass: #PluggableListSpec	instanceVariableNames: 'list getIndex setIndex getSelected setSelected menu keyPress autoDeselect dragItem dropItem dropAccept doubleClick listSize listItem keystrokePreview icon vScrollBarPolicy hScrollBarPolicy dragStarted helpItem filterableList clearFilterAutomatically'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableListSpec commentStamp: 'ar 7/15/2005 11:54' prior: 0!A single selection list element.Instance variables:	list		<Symbol>	The selector to retrieve the list elements.	getIndex	<Symbol>	The selector to retrieve the list selection index.	setIndex	<Symbol>	The selector to set the list selection index.	getSelected	<Symbol>	The selector to retrieve the list selection.	setSelected	<Symbol>	The selector to set the list selection.	menu	<Symbol>	The selector to offer (to retrieve?) the context menu.	keyPress <Symbol>	The selector to invoke for handling keyboard shortcuts.	autoDeselect	<Boolean>	Whether the list should allow automatic deselection or not.	dragItem	<Symbol>	Selector to initiate a drag action on an item	dropItem	<Symbol>	Selector to initiate a drop action of an item	dropAccept	<Symbol>	Selector to determine whether a drop would be accepted!!PluggableListSpec methodsFor: 'accessing' stamp: 'jcg 12/12/2009 10:34'!doubleClick	"Answer the selector to perform when a double-click occurs"	^doubleClick! !!PluggableListSpec methodsFor: 'accessing' stamp: 'jcg 12/12/2009 10:34'!doubleClick: aSymbol	"Set the selector to perform when a double-click occurs"	doubleClick := aSymbol.! !!PluggableListSpec methodsFor: 'accessing' stamp: 'mt 4/19/2015 07:40'!hScrollBarPolicy	^ hScrollBarPolicy! !!PluggableListSpec methodsFor: 'accessing' stamp: 'mt 4/19/2015 07:41'!hScrollBarPolicy: aSymbol	"#always, #never, #whenNeeded"	hScrollBarPolicy := aSymbol.! !!PluggableListSpec methodsFor: 'accessing' stamp: 'mt 4/5/2016 10:18'!helpItem		^ helpItem! !!PluggableListSpec methodsFor: 'accessing' stamp: 'mt 4/5/2016 10:18'!helpItem: selector		helpItem := selector.! !!PluggableListSpec methodsFor: 'accessing' stamp: 'cwp 12/8/2011 12:01'!icon	^ icon! !!PluggableListSpec methodsFor: 'accessing' stamp: 'cwp 12/8/2011 12:02'!icon: aSelector	icon := aSelector! !!PluggableListSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:23'!keyPress	"Answer the selector for invoking the list's keyPress handler"	^keyPress! !!PluggableListSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:23'!keyPress: aSymbol	"Indicate the selector for invoking the list's keyPress handler"	keyPress := aSymbol! !!PluggableListSpec methodsFor: 'accessing' stamp: 'MAD 3/15/2010 11:34'!keystrokePreview	"Answer the selector to determine whether to allow the model a preview of keystrokes"	^ keystrokePreview! !!PluggableListSpec methodsFor: 'accessing' stamp: 'MAD 3/15/2010 11:35'!keystrokePreview: aSymbol	"The selector to determine whether to allow the model a preview of keystrokes"	keystrokePreview := aSymbol.! !!PluggableListSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:22'!menu	"Answer the selector for retrieving the list's menu"	^menu! !!PluggableListSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:22'!menu: aSymbol	"Indicate the selector for retrieving the list's menu"	menu := aSymbol! !!PluggableListSpec methodsFor: 'accessing' stamp: 'mt 4/19/2015 07:42'!vScrollBarPolicy	^ vScrollBarPolicy! !!PluggableListSpec methodsFor: 'accessing' stamp: 'mt 4/19/2015 07:42'!vScrollBarPolicy: aSymbol	"#always, #never, #whenNeeded"		vScrollBarPolicy := aSymbol.! !!PluggableListSpec methodsFor: 'accessing - drag and drop' stamp: 'ar 7/15/2005 11:07'!dragItem	"Answer the selector for dragging an item"	^dragItem! !!PluggableListSpec methodsFor: 'accessing - drag and drop' stamp: 'ar 7/15/2005 11:07'!dragItem: aSymbol	"Set the selector for dragging an item"	dragItem := aSymbol! !!PluggableListSpec methodsFor: 'accessing - drag and drop' stamp: 'mt 11/4/2015 14:38'!dragStarted	^ dragStarted! !!PluggableListSpec methodsFor: 'accessing - drag and drop' stamp: 'mt 11/4/2015 14:38'!dragStarted: symbol	dragStarted := symbol.! !!PluggableListSpec methodsFor: 'accessing - drag and drop' stamp: 'ar 7/15/2005 11:54'!dropAccept	"Answer the selector to determine whether a drop would be accepted"	^dropAccept! !!PluggableListSpec methodsFor: 'accessing - drag and drop' stamp: 'ar 7/15/2005 11:55'!dropAccept: aSymbol	"Answer the selector to determine whether a drop would be accepted"	dropAccept := aSymbol.! !!PluggableListSpec methodsFor: 'accessing - drag and drop' stamp: 'ar 7/15/2005 11:07'!dropItem	"Answer the selector for dropping an item"	^dropItem! !!PluggableListSpec methodsFor: 'accessing - drag and drop' stamp: 'ar 7/15/2005 11:07'!dropItem: aSymbol	"Set the selector for dropping an item"	dropItem := aSymbol! !!PluggableListSpec methodsFor: 'accessing - list' stamp: 'mt 8/10/2016 15:43'!clearFilterAutomatically	^ clearFilterAutomatically! !!PluggableListSpec methodsFor: 'accessing - list' stamp: 'mt 8/10/2016 15:43'!clearFilterAutomatically: aBoolean	clearFilterAutomatically := aBoolean.! !!PluggableListSpec methodsFor: 'accessing - list' stamp: 'mt 8/10/2016 14:53'!filterableList	^ filterableList! !!PluggableListSpec methodsFor: 'accessing - list' stamp: 'mt 8/10/2016 14:53'!filterableList: aBoolean	filterableList := aBoolean.! !!PluggableListSpec methodsFor: 'accessing - list' stamp: 'ar 2/9/2005 18:20'!list	"Answer the selector for retrieving the list contents"	^list! !!PluggableListSpec methodsFor: 'accessing - list' stamp: 'ar 2/9/2005 19:24'!list: aSymbol	"Indicate the selector for retrieving the list contents"	list := aSymbol.! !!PluggableListSpec methodsFor: 'accessing - list' stamp: 'mtf 9/27/2007 11:13'!listItem	"Answer the selector for retrieving the list element"	^listItem! !!PluggableListSpec methodsFor: 'accessing - list' stamp: 'mtf 9/27/2007 11:13'!listItem: aSymbol	"Indicate the selector for retrieving the list element"	listItem := aSymbol.! !!PluggableListSpec methodsFor: 'accessing - list' stamp: 'mtf 9/27/2007 11:11'!listSize	"Answer the selector for retrieving the list size"	^listSize! !!PluggableListSpec methodsFor: 'accessing - list' stamp: 'mtf 9/27/2007 11:12'!listSize: aSymbol	"Indicate the selector for retrieving the list size"	listSize := aSymbol.! !!PluggableListSpec methodsFor: 'accessing - selection' stamp: 'ar 2/12/2005 16:42'!autoDeselect	"Answer whether this tree can be automatically deselected"	^autoDeselect ifNil:[true]! !!PluggableListSpec methodsFor: 'accessing - selection' stamp: 'ar 2/12/2005 16:41'!autoDeselect: aBool	"Indicate whether this tree can be automatically deselected"	autoDeselect := aBool! !!PluggableListSpec methodsFor: 'accessing - selection' stamp: 'ar 2/9/2005 18:21'!getIndex	"Answer the selector for retrieving the list's selection index"	^getIndex! !!PluggableListSpec methodsFor: 'accessing - selection' stamp: 'ar 2/9/2005 18:21'!getIndex: aSymbol	"Indicate the selector for retrieving the list's selection index"	getIndex := aSymbol! !!PluggableListSpec methodsFor: 'accessing - selection' stamp: 'ar 2/10/2005 22:33'!getSelected	"Answer the selector for retrieving the list selection"	^getSelected! !!PluggableListSpec methodsFor: 'accessing - selection' stamp: 'ar 2/10/2005 22:33'!getSelected: aSymbol	"Indicate the selector for retrieving the list selection"	getSelected := aSymbol! !!PluggableListSpec methodsFor: 'accessing - selection' stamp: 'ar 2/9/2005 18:21'!setIndex	"Answer the selector for setting the list's selection index"	^setIndex! !!PluggableListSpec methodsFor: 'accessing - selection' stamp: 'ar 2/9/2005 18:21'!setIndex: aSymbol	"Answer the selector for setting the list's selection index"	setIndex := aSymbol! !!PluggableListSpec methodsFor: 'accessing - selection' stamp: 'ar 2/10/2005 22:34'!setSelected	"Answer the selector for setting the list selection"	^setSelected! !!PluggableListSpec methodsFor: 'accessing - selection' stamp: 'ar 2/10/2005 22:33'!setSelected: aSymbol	"Indicate the selector for setting the list selection"	setSelected := aSymbol! !!PluggableListSpec methodsFor: 'building' stamp: 'ar 2/12/2005 18:16'!buildWith: builder	^builder buildPluggableList: self! !PluggableListSpec subclass: #PluggableMultiColumnListSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableMultiColumnListSpec methodsFor: 'building' stamp: 'tpr 11/7/2017 10:01'!buildWith: builder	^builder buildPluggableMultiColumnList: self! !PluggableListSpec subclass: #PluggableMultiSelectionListSpec	instanceVariableNames: 'getSelectionList setSelectionList'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableMultiSelectionListSpec commentStamp: 'ar 2/12/2005 13:31' prior: 0!PluggableMultiSelectionListSpec specifies a list with multiple selection behavior.Instance variables:	getSelectionList	<Symbol>	The message to retrieve the multiple selections.	setSelectionList	<Symbol>	The message to indicate multiple selections.!!PluggableMultiSelectionListSpec methodsFor: 'accessing' stamp: 'ar 2/12/2005 13:32'!getSelectionList	"Answer the message to retrieve the multiple selections"	^getSelectionList! !!PluggableMultiSelectionListSpec methodsFor: 'accessing' stamp: 'ar 2/12/2005 13:32'!getSelectionList: aSymbol	"Indicate the message to retrieve the multiple selections"	getSelectionList := aSymbol! !!PluggableMultiSelectionListSpec methodsFor: 'accessing' stamp: 'ar 2/12/2005 13:32'!setSelectionList	"Answer the message to indicate multiple selections"	^setSelectionList! !!PluggableMultiSelectionListSpec methodsFor: 'accessing' stamp: 'ar 2/12/2005 13:32'!setSelectionList: aSymbol	"Indicate the message to indicate multiple selections"	setSelectionList := aSymbol! !!PluggableMultiSelectionListSpec methodsFor: 'building' stamp: 'ar 2/12/2005 18:16'!buildWith: builder	^builder buildPluggableMultiSelectionList: self! !PluggableMultiSelectionListSpec subclass: #PluggableAlternateMultiSelectionListSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableAlternateMultiSelectionListSpec methodsFor: 'building' stamp: 'cmm 2/19/2010 14:26'!buildWith: builder	^ builder buildPluggableAlternateMultiSelectionList: self! !PluggableCompositeSpec subclass: #PluggablePanelSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggablePanelSpec commentStamp: 'ar 2/11/2005 15:01' prior: 0!A panel with a (possibly changing) set of child elements. Expects to see change/update notifications when the childrens change.!!PluggablePanelSpec methodsFor: 'building' stamp: 'ar 2/12/2005 18:16'!buildWith: builder	^builder buildPluggablePanel: self.! !PluggableWidgetSpec subclass: #PluggablePasteUpMorphSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggablePasteUpMorphSpec methodsFor: 'as yet unclassified' stamp: 'pascal 5/13/2018 12:26'!buildWith: builder	^builder buildPasteUpMorph: self! !PluggableButtonSpec subclass: #PluggableRadioButtonSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableRadioButtonSpec commentStamp: 'ar 2/12/2005 23:14' prior: 0!PluggableRadioButton is intended as a HINT for the builder that this widget will be used as radio button. Unless explicitly supported it will be automatically substituted by PluggableButton.!!PluggableRadioButtonSpec methodsFor: 'building' stamp: 'ar 2/12/2005 18:16'!buildWith: builder	^builder buildPluggableRadioButton: self! !PluggableCompositeSpec subclass: #PluggableScrollPaneSpec	instanceVariableNames: 'morph morphClass borderWidth vScrollBarPolicy hScrollBarPolicy'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableScrollPaneSpec methodsFor: 'accessing' stamp: 'mt 7/26/2016 11:24'!borderWidth	^ borderWidth! !!PluggableScrollPaneSpec methodsFor: 'accessing' stamp: 'mt 6/15/2014 07:27:49.47'!borderWidth: anObject	borderWidth := anObject! !!PluggableScrollPaneSpec methodsFor: 'accessing' stamp: 'mt 6/5/2016 12:56'!hScrollBarPolicy	^ hScrollBarPolicy! !!PluggableScrollPaneSpec methodsFor: 'accessing' stamp: 'mt 6/15/2014 07:34:08.997'!hScrollBarPolicy: anObject	"#always, #never, #whenNeeded"	hScrollBarPolicy := anObject! !!PluggableScrollPaneSpec methodsFor: 'accessing' stamp: 'mt 6/15/2014 07:17:36.829'!morph	^ morph! !!PluggableScrollPaneSpec methodsFor: 'accessing' stamp: 'mt 6/15/2014 07:17:36.953'!morph: anObject	morph := anObject! !!PluggableScrollPaneSpec methodsFor: 'accessing' stamp: 'mt 6/15/2014 07:17:37.06'!morphClass	^ morphClass! !!PluggableScrollPaneSpec methodsFor: 'accessing' stamp: 'mt 6/15/2014 07:17:37.166'!morphClass: anObject	morphClass := anObject! !!PluggableScrollPaneSpec methodsFor: 'accessing' stamp: 'mt 6/5/2016 12:57'!vScrollBarPolicy	^ vScrollBarPolicy! !!PluggableScrollPaneSpec methodsFor: 'accessing' stamp: 'mt 6/15/2014 07:33:45.268'!vScrollBarPolicy: anObject	"#always, #never, #whenNeeded"		vScrollBarPolicy := anObject! !!PluggableScrollPaneSpec methodsFor: 'building' stamp: 'mt 6/15/2014 07:20:48.063'!buildWith: builder	^ builder buildPluggableScrollPane: self! !PluggableWidgetSpec subclass: #PluggableSpacerSpec	instanceVariableNames: 'extent'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableSpacerSpec methodsFor: 'accessing' stamp: 'mt 5/3/2015 14:55'!horizontalResizing	^ super horizontalResizing ifNil: [#rigid]! !!PluggableSpacerSpec methodsFor: 'accessing' stamp: 'mt 5/3/2015 14:55'!verticalResizing	^ super verticalResizing ifNil: [#rigid]! !!PluggableSpacerSpec methodsFor: 'building' stamp: 'mt 5/3/2015 14:47'!buildWith: builder	^builder buildPluggableSpacer: self! !!PluggableSpacerSpec methodsFor: 'convenience' stamp: 'mt 5/3/2015 14:53'!fillSpaceHorizontally	self horizontalResizing: #spaceFill.! !!PluggableSpacerSpec methodsFor: 'convenience' stamp: 'mt 5/3/2015 14:53'!fillSpaceVertically	self verticalResizing: #spaceFill.! !!PluggableSpacerSpec methodsFor: 'layout hints' stamp: 'mt 5/3/2015 15:01'!extent	^ extent ifNil: [5@5]! !!PluggableSpacerSpec methodsFor: 'layout hints' stamp: 'mt 5/3/2015 14:52'!extent: aPoint	extent := aPoint.! !PluggableWidgetSpec subclass: #PluggableTextSpec	instanceVariableNames: 'getText setText selection menu askBeforeDiscardingEdits editText indicateUnacceptedChanges stylerClass font readOnly softLineWrap hardLineWrap textColor'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableTextSpec commentStamp: 'ar 2/11/2005 21:58' prior: 0!A text editor.Instance variables:	getText	<Symbol>	The selector to retrieve the text.	setText	<Symbol>	The selector to set the text.	selection <Symbol>	The selector to retrieve the text selection.	menu	<Symbol>	The selector to offer (to retrieve?) the context menu.	color	 <Symbol>	The selector to retrieve the background color.!!PluggableTextSpec methodsFor: 'accessing' stamp: 'ar 10/4/2009 21:15'!askBeforeDiscardingEdits	^askBeforeDiscardingEdits ifNil:[true]! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'ar 10/4/2009 21:14'!askBeforeDiscardingEdits: aBool	askBeforeDiscardingEdits := aBool! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'mt 4/7/2015 08:54'!editText	^ editText! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'mt 4/7/2015 08:54'!editText: aSymbol	"Answer the selector for getting informed about any modifications of the text."	editText := aSymbol! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'mt 4/28/2015 12:05'!font	^ font ifNil: [Preferences standardDefaultTextFont]! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'mt 4/17/2015 15:01'!font: aFont	font := aFont.! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:23'!getText	"Answer the selector for retrieving the text"	^getText! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:23'!getText: aSymbol	"Answer the selector for retrieving the text"	getText := aSymbol! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'mt 4/27/2015 15:43'!hardLineWrap	^ hardLineWrap! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'mt 4/27/2015 15:43'!hardLineWrap: aBoolean	hardLineWrap := aBoolean.! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'mt 4/16/2015 22:44'!indicateUnacceptedChanges	^ indicateUnacceptedChanges ifNil: [true]! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'mt 4/16/2015 22:44'!indicateUnacceptedChanges: aBoolean	indicateUnacceptedChanges := aBoolean.! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:25'!menu	"Answer the selector for retrieving the text's menu"	^menu! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:26'!menu: aSymbol	"Indicate the selector for retrieving the text's menu"	menu := aSymbol! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'mt 4/19/2015 13:54'!readOnly	^ readOnly ifNil: [false]! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'mt 4/19/2015 13:54'!readOnly: aBoolean	readOnly := aBoolean.! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:25'!selection	"Answer the selector for retrieving the text selection"	^selection! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:25'!selection: aSymbol	"Indicate the selector for retrieving the text selection"	selection := aSymbol! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:24'!setText	"Answer the selector for setting the text"	^setText! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:24'!setText: aSymbol	"Answer the selector for setting the text"	setText := aSymbol! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'mt 4/27/2015 15:43'!softLineWrap	^ softLineWrap! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'mt 4/27/2015 15:43'!softLineWrap: aBoolean	softLineWrap := aBoolean.! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'mt 4/17/2015 14:53'!stylerClass	^ stylerClass! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'mt 4/17/2015 14:53'!stylerClass: aStylerClass	stylerClass := aStylerClass.! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'mt 8/16/2016 13:11'!textColor	^ textColor! !!PluggableTextSpec methodsFor: 'accessing' stamp: 'mt 8/16/2016 13:11'!textColor: aSymbol	textColor := aSymbol.! !!PluggableTextSpec methodsFor: 'building' stamp: 'ar 2/12/2005 18:16'!buildWith: builder	^builder buildPluggableText: self! !PluggableTextSpec subclass: #PluggableCodePaneSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableCodePaneSpec commentStamp: 'ar 8/18/2009 00:02' prior: 0!A PluggableTextSpec specifically intended to edit code. Uses Syntax-Highlighting.!!PluggableCodePaneSpec methodsFor: 'accessing' stamp: 'mt 4/28/2015 12:04'!font	^ font ifNil: [Preferences standardCodeFont]! !!PluggableCodePaneSpec methodsFor: 'accessing' stamp: 'mt 4/17/2015 14:57'!stylerClass	^ super stylerClass ifNil: [Smalltalk classNamed: 'SHTextStylerST80']! !!PluggableCodePaneSpec methodsFor: 'building' stamp: 'ar 8/18/2009 00:03'!buildWith: builder	^builder buildPluggableCodePane: self! !PluggableTextSpec subclass: #PluggableInputFieldSpec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableInputFieldSpec commentStamp: 'ar 2/12/2005 23:13' prior: 0!PluggableInputField is intended as a HINT for the builder that this widget will be used as a single line input field. Unless explicitly supported it will be automatically substituted by PluggableText.!!PluggableInputFieldSpec methodsFor: 'accessing' stamp: 'mt 4/27/2015 15:44'!hardLineWrap	^ false! !!PluggableInputFieldSpec methodsFor: 'accessing' stamp: 'mt 5/12/2015 21:01'!softLineWrap	^ super softLineWrap ifNil: [false]! !!PluggableInputFieldSpec methodsFor: 'building' stamp: 'ar 2/12/2005 18:16'!buildWith: builder	^builder buildPluggableInputField: self! !PluggableWidgetSpec subclass: #PluggableTreeSpec	instanceVariableNames: 'roots getSelectedPath setSelected getSelected setSelectedParent getChildren hasChildren label icon unusedVar menu keyPress doubleClick dropItem dropAccept autoDeselect dragItem nodeClass columns vScrollBarPolicy hScrollBarPolicy dragStarted'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableTreeSpec commentStamp: 'mvdg 3/21/2008 20:59' prior: 0!A pluggable tree widget. PluggableTrees are slightly different from lists in such that they ALWAYS store the actual objects and use the label selector to query for the label of the item. PluggableTrees also behave somewhat differently in such that they do not have a "getSelected" message but only a getSelectedPath message. The difference is that getSelectedPath is used to indicate by the model that the tree should select the appropriate path. This allows disambiguation of items. Because of this, implementations of PluggableTrees must always set their internal selection directly, e.g., rather than sending the model a setSelected message and wait for an update of the #getSelected the implementation must set the selection before sending the #setSelected message. If a client doesn't want this, it can always just signal a change of getSelectedPath to revert to whatever is needed.Instance variables:	roots 	<Symbol>	The message to retrieve the roots of the tree.	getSelectedPath	<Symbol> The message to retrieve the selected path in the tree.	setSelected	<Symbol>	The message to set the selected item in the tree.	getChildren	<Symbol>	The message to retrieve the children of an item	hasChildren	<Symbol>	The message to query for children of an item	label 	<Symbol>	The message to query for the label of an item.	icon 	<Symbol>	The message to query for the icon of an item.	help 	<Symbol>	The message to query for the help of an item.	menu	<Symbol>	The message to query for the tree's menu	keyPress	<Symbol>	The message to process a keystroke.	wantsDrop	<Symbol>	The message to query whether a drop might be accepted.	dropItem	<Symbol>	The message to drop an item.	enableDrag <Boolean>	Enable dragging from this tree.	autoDeselect	<Boolean>	Whether the tree should allow automatic deselection or not.	unusedVar	(unused)	This variable is a placeholder to fix problems with loading packages in 3.10.!!PluggableTreeSpec methodsFor: 'accessing' stamp: 'mt 3/6/2015 16:52'!columns	^ columns! !!PluggableTreeSpec methodsFor: 'accessing' stamp: 'mt 3/6/2015 16:52'!columns: columnSpecs	columns := columnSpecs.! !!PluggableTreeSpec methodsFor: 'accessing' stamp: 'pre 4/25/2017 12:05'!doubleClick	"Answer the selector for reacting to a double click"	^ doubleClick! !!PluggableTreeSpec methodsFor: 'accessing' stamp: 'pre 4/25/2017 12:05'!doubleClick: selector	"Set the selector for reacting to a double click"	doubleClick := selector! !!PluggableTreeSpec methodsFor: 'accessing' stamp: 'mt 11/4/2015 10:23'!hScrollBarPolicy	^ hScrollBarPolicy! !!PluggableTreeSpec methodsFor: 'accessing' stamp: 'mt 11/4/2015 10:23'!hScrollBarPolicy: aSymbol	"#always, #never, #whenNeeded"	hScrollBarPolicy := aSymbol.! !!PluggableTreeSpec methodsFor: 'accessing' stamp: 'ar 2/12/2005 00:32'!icon	"Answer the message to get the icons of this tree"	^icon! !!PluggableTreeSpec methodsFor: 'accessing' stamp: 'ar 2/12/2005 00:32'!icon: aSymbol	"Indicate the message to retrieve the icon of this tree"	icon := aSymbol! !!PluggableTreeSpec methodsFor: 'accessing' stamp: 'ar 2/12/2005 00:34'!keyPress	"Answer the selector for invoking the tree's keyPress handler"	^keyPress! !!PluggableTreeSpec methodsFor: 'accessing' stamp: 'ar 2/12/2005 00:34'!keyPress: aSymbol	"Indicate the selector for invoking the tree's keyPress handler"	keyPress := aSymbol! !!PluggableTreeSpec methodsFor: 'accessing' stamp: 'ar 2/12/2005 00:32'!label	"Answer the message to get the labels of this tree"	^label! !!PluggableTreeSpec methodsFor: 'accessing' stamp: 'ar 2/12/2005 00:32'!label: aSymbol	"Indicate the message to retrieve the labels of this tree"	label := aSymbol! !!PluggableTreeSpec methodsFor: 'accessing' stamp: 'ar 2/12/2005 00:33'!menu	"Answer the message to get the menus of this tree"	^menu! !!PluggableTreeSpec methodsFor: 'accessing' stamp: 'ar 2/12/2005 00:33'!menu: aSymbol	"Indicate the message to retrieve the menus of this tree"	menu := aSymbol! !!PluggableTreeSpec methodsFor: 'accessing' stamp: 'mt 3/6/2015 16:28'!nodeClass	^ nodeClass! !!PluggableTreeSpec methodsFor: 'accessing' stamp: 'mt 3/6/2015 16:29'!nodeClass: aListWrapperClass	nodeClass := aListWrapperClass.! !!PluggableTreeSpec methodsFor: 'accessing' stamp: 'mt 11/4/2015 10:23'!vScrollBarPolicy	^ vScrollBarPolicy! !!PluggableTreeSpec methodsFor: 'accessing' stamp: 'mt 11/4/2015 10:23'!vScrollBarPolicy: aSymbol	"#always, #never, #whenNeeded"		vScrollBarPolicy := aSymbol.! !!PluggableTreeSpec methodsFor: 'accessing - drag and drop' stamp: 'mvdg 2/11/2007 13:47'!dragItem	^ dragItem.! !!PluggableTreeSpec methodsFor: 'accessing - drag and drop' stamp: 'mvdg 2/11/2007 13:47'!dragItem: aSymbol	"Set the selector for dragging an item"	dragItem := aSymbol! !!PluggableTreeSpec methodsFor: 'accessing - drag and drop' stamp: 'mt 11/4/2015 14:21'!dragStarted	^ dragStarted! !!PluggableTreeSpec methodsFor: 'accessing - drag and drop' stamp: 'mt 11/4/2015 14:21'!dragStarted: symbol	dragStarted := symbol.! !!PluggableTreeSpec methodsFor: 'accessing - drag and drop' stamp: 'ar 7/15/2005 12:09'!dropAccept	"Answer the selector for querying the receiver about accepting drops"	^dropAccept! !!PluggableTreeSpec methodsFor: 'accessing - drag and drop' stamp: 'ar 7/15/2005 12:09'!dropAccept: aSymbol	"Set the selector for querying the receiver about accepting drops"	dropAccept := aSymbol! !!PluggableTreeSpec methodsFor: 'accessing - drag and drop' stamp: 'ar 2/12/2005 00:35'!dropItem	"Answer the selector for invoking the tree's dragDrop handler"	^dropItem! !!PluggableTreeSpec methodsFor: 'accessing - drag and drop' stamp: 'ar 2/12/2005 00:35'!dropItem: aSymbol	"Indicate the selector for invoking the tree's dragDrop handler"	dropItem := aSymbol! !!PluggableTreeSpec methodsFor: 'accessing - hierarchy' stamp: 'ar 2/12/2005 00:31'!getChildren	"Answer the message to get the children of this tree"	^getChildren! !!PluggableTreeSpec methodsFor: 'accessing - hierarchy' stamp: 'ar 2/12/2005 00:31'!getChildren: aSymbol	"Indicate the message to retrieve the children of this tree"	getChildren := aSymbol! !!PluggableTreeSpec methodsFor: 'accessing - hierarchy' stamp: 'ar 2/12/2005 00:31'!hasChildren	"Answer the message to get the existence of children in this tree"	^hasChildren! !!PluggableTreeSpec methodsFor: 'accessing - hierarchy' stamp: 'ar 2/12/2005 00:31'!hasChildren: aSymbol	"Indicate the message to retrieve the existence children in this tree"	hasChildren := aSymbol! !!PluggableTreeSpec methodsFor: 'accessing - hierarchy' stamp: 'ar 2/12/2005 00:29'!roots	"Answer the message to retrieve the roots of this tree"	^roots! !!PluggableTreeSpec methodsFor: 'accessing - hierarchy' stamp: 'ar 2/12/2005 00:30'!roots: aSymbol	"Indicate the message to retrieve the roots of this tree"	roots := aSymbol! !!PluggableTreeSpec methodsFor: 'accessing - selection' stamp: 'ar 2/12/2005 17:38'!autoDeselect	"Answer whether this tree can be automatically deselected"	^autoDeselect ifNil:[true]! !!PluggableTreeSpec methodsFor: 'accessing - selection' stamp: 'mvdg 3/21/2008 18:09'!autoDeselect: aBool	"Indicate whether this tree can be automatically deselected"	autoDeselect := aBool.! !!PluggableTreeSpec methodsFor: 'accessing - selection' stamp: 'mt 3/7/2015 08:54'!getSelected	^ getSelected! !!PluggableTreeSpec methodsFor: 'accessing - selection' stamp: 'mt 3/7/2015 08:55'!getSelected: aSymbol	"Indicate a single node in the tree. Only works if that node is visible, too. Use #getSelectedPath otherwise."		getSelected := aSymbol.! !!PluggableTreeSpec methodsFor: 'accessing - selection' stamp: 'ar 2/12/2005 03:28'!getSelectedPath	"Answer the message to retrieve the selection of this tree"	^getSelectedPath! !!PluggableTreeSpec methodsFor: 'accessing - selection' stamp: 'ar 2/12/2005 03:28'!getSelectedPath: aSymbol	"Indicate the message to retrieve the selection of this tree"	getSelectedPath := aSymbol! !!PluggableTreeSpec methodsFor: 'accessing - selection' stamp: 'ar 2/12/2005 00:30'!setSelected	"Answer the message to set the selection of this tree"	^setSelected! !!PluggableTreeSpec methodsFor: 'accessing - selection' stamp: 'ar 2/12/2005 00:30'!setSelected: aSymbol	"Indicate the message to set the selection of this tree"	setSelected := aSymbol! !!PluggableTreeSpec methodsFor: 'accessing - selection' stamp: 'mt 3/7/2015 09:31'!setSelectedParent	^ setSelectedParent! !!PluggableTreeSpec methodsFor: 'accessing - selection' stamp: 'mt 3/7/2015 09:31'!setSelectedParent: aSymbol	setSelectedParent := aSymbol! !!PluggableTreeSpec methodsFor: 'building' stamp: 'ar 2/12/2005 18:16'!buildWith: builder	^builder buildPluggableTree: self! !PluggableCompositeSpec subclass: #PluggableWindowSpec	instanceVariableNames: 'label extent closeAction multiWindowStyle'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!PluggableWindowSpec commentStamp: '<historical>' prior: 0!A common window. Expects to see change/update notifications when the label should change.Instance variables:	label	<String|Symbol> The selector under which to retrieve the label or the label directly	extent	<Point>	The (initial) extent of the window.	closeAction		<Symbol>	The action to perform when the window is closed.!!PluggableWindowSpec methodsFor: 'accessing' stamp: 'ar 9/17/2005 21:00'!closeAction	"Answer the receiver's closeAction"	^closeAction! !!PluggableWindowSpec methodsFor: 'accessing' stamp: 'ar 9/17/2005 21:00'!closeAction: aSymbol	"Answer the receiver's closeAction"	closeAction := aSymbol.! !!PluggableWindowSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:30'!extent	"Answer the window's (initial) extent"	^extent! !!PluggableWindowSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:30'!extent: aPoint	"Indicate the window's (initial) extent"	extent := aPoint! !!PluggableWindowSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:29'!label	"Answer the selector for retrieving the window's label"	^label! !!PluggableWindowSpec methodsFor: 'accessing' stamp: 'ar 2/9/2005 18:30'!label: aString	"Indicate the selector for retrieving the window's label"	label := aString! !!PluggableWindowSpec methodsFor: 'accessing' stamp: 'eem 7/1/2010 11:31'!multiWindowStyle	"Answer the value of multiWindowStyle, a Symbol or nil"	^multiWindowStyle! !!PluggableWindowSpec methodsFor: 'accessing' stamp: 'eem 6/30/2010 11:44'!multiWindowStyle: aSymbol	"Set the value of multiWindowStyle, one of #labelButton or #tabbed"	multiWindowStyle := aSymbol! !!PluggableWindowSpec methodsFor: 'building' stamp: 'ar 2/12/2005 18:16'!buildWith: builder	^builder buildPluggableWindow: self.! !Object subclass: #UIManager	instanceVariableNames: 'builderClass'	classVariableNames: 'OpenToolsAttachedToMouseCursor'	poolDictionaries: ''	category: 'ToolBuilder-Kernel'!!UIManager commentStamp: 'dtl 5/2/2010 16:06' prior: 0!UIManager is a dispatcher for various user interface requests, such as menu and dialog interactions. An instance of UIManager is associated with each Project to implement the appropriate functions for Morphic, MVC or other user interfaces.!!UIManager methodsFor: '*51Deprecated' stamp: 'mt 5/9/2016 11:18'!newDisplayDepthNoRestore: pixelSize	self deprecated.	Display newDepth: pixelSize.! !!UIManager methodsFor: '*51Deprecated' stamp: 'mt 5/9/2016 10:59'!restoreDisplay	Display restore.! !!UIManager methodsFor: '*51Deprecated' stamp: 'mt 5/9/2016 10:58'!restoreDisplayAfter: aBlock	self deprecated.	Display restoreAfter: aBlock.! !!UIManager methodsFor: '*Regex-Core' stamp: 'CamilloBruni 11/21/2012 00:52'!request: aTitleString regex: initialRegexString	"Prompt the user for a valid regex.	Return nil on cancel or a valid RxMatcher"	| regex |	regex := initialRegexString.	"loop until we get a valid regex string back"	[		regex := UIManager default 			multiLineRequest: aTitleString 			initialAnswer: regex 			answerHeight: 200.		"cancelled dialog ==> nil"			regex ifNil: [ ^ nil ].				[ ^ regex asRegex ] on: Error do: [ :regexParsingError|			self defer: [	self inform: 'Bad Regex: ', regexParsingError asString ]].	] repeat.! !!UIManager methodsFor: 'accessing' stamp: 'dtl 3/23/2015 07:29'!builderClass: aClass	builderClass := aClass! !!UIManager methodsFor: 'accessing' stamp: 'mt 8/16/2016 17:47'!openToolsAttachedToMouseCursor	self flag: #todo. "mt: Let each instances of ui manager have its own setting."	^ self class openToolsAttachedToMouseCursor! !!UIManager methodsFor: 'accessing' stamp: 'mt 8/16/2016 17:47'!openToolsAttachedToMouseCursor: aBoolean	self flag: #todo. "mt: Let each instances of ui manager have its own setting."	self class openToolsAttachedToMouseCursor: aBoolean.! !!UIManager methodsFor: 'accessing' stamp: 'cmm 6/15/2011 14:50'!screenBounds	^ Display boundingBox! !!UIManager methodsFor: 'builder' stamp: 'dtl 3/21/2015 11:50'!builderClass	"Answer the kind of tool builder to use, possibly influenced by project preferences"	^ builderClass ifNil: [ builderClass := ToolBuilder findDefault ]! !!UIManager methodsFor: 'builder' stamp: 'dtl 3/21/2015 11:51'!toolBuilder	^ self builderClass new! !!UIManager methodsFor: 'system introspecting' stamp: 'jr 2/28/2017 01:28'!classFromPattern: pattern withCaption: aCaption	^self classFromPattern: pattern withCaption: aCaption in: Smalltalk environment"	self classFromPattern: 'CharRecog' withCaption: ''	self classFromPattern: 'rRecog' withCaption: ''	self classFromPattern: 'znak' withCaption: ''	self classFromPattern: 'orph' withCaption: ''	self classFromPattern: 'TCompil' withCaption: ''"! !!UIManager methodsFor: 'system introspecting' stamp: 'jr 2/28/2017 01:29'!classFromPattern: pattern withCaption: aCaption in: anEnvironment	"If there is a class or trait whose name exactly given by pattern, return it.	If there is only one class or trait in the system whose name matches pattern, return it.	Otherwise, put up a menu offering the names of all classes that match pattern, and return the class chosen, else nil if nothing chosen.	This method ignores separator characters in the pattern"	^self classOrTraitFrom: anEnvironment pattern: pattern label: aCaption"	for examples, see #classFromPattern:withCaption:"! !!UIManager methodsFor: 'system introspecting' stamp: 'topa 10/20/2015 08:53:36'!classOrTraitFrom: environment pattern: pattern label: label	"If there is a class or trait whose name exactly given by pattern, return it.	If there is only one class or trait in the given environment whose name matches pattern, return it.	Otherwise, put up a menu offering the names of all classes that match pattern, and return the class chosen, else nil if nothing chosen.	This method ignores separator characters in the pattern"		| toMatch potentialNames names exactMatch lines reducedIdentifiers selectedIndex |	toMatch := pattern copyWithoutAll: Character separators.	toMatch ifEmpty: [ ^nil ].	"If there's a class or trait named as pattern, then return it."	Symbol hasInterned: pattern ifTrue: [ :symbol |		environment at: symbol ifPresent: [ :maybeClassOrTrait |			((maybeClassOrTrait isKindOf: Class) or: [				maybeClassOrTrait isTrait ])					ifTrue: [ ^maybeClassOrTrait ] ] ].	"No exact match, look for potential matches."	toMatch := pattern asLowercase copyWithout: $..	potentialNames := (environment classAndTraitNames) asOrderedCollection.	names := pattern last = $. "This is some old hack, using String>>#match: may be better."		ifTrue: [ potentialNames select: [ :each | each asLowercase = toMatch ] ]		ifFalse: [			potentialNames select: [ :each |				each includesSubstring: toMatch caseSensitive: false ] ].	exactMatch := names detect: [ :each | each asLowercase = toMatch ] ifNone: [ nil ].	lines := OrderedCollection new.	exactMatch ifNotNil: [ lines add: 1 ].	"Also try some fuzzy matching."	reducedIdentifiers := pattern suggestedTypeNames select: [ :each |		potentialNames includes: each ].	reducedIdentifiers ifNotEmpty: [		names addAll: reducedIdentifiers.		lines add: 1 + names size + reducedIdentifiers size ].	"Let the user select if there's more than one possible match. This may give surprising results."	names size = 0 ifTrue: [^ nil "nothing matches"].		selectedIndex := names size = 1		ifTrue: [ 1 ]		ifFalse: [			exactMatch ifNotNil: [ names addFirst: exactMatch ].			self chooseFrom: names lines: lines title: label ].	selectedIndex = 0 ifTrue: [ ^nil ].	^environment at: (names at: selectedIndex) asSymbol! !!UIManager methodsFor: 'ui project indirecting' stamp: 'tpr 1/29/2018 20:16'!openDebugger: aDebugger on: process context: context label: title contents: contentsStringOrNil fullView: bool	"open a debugger - the two versions for mvc & morphic are very close and can surely be merged so that this can be removed"	^self subclassResponsibility! !!UIManager methodsFor: 'ui project indirecting' stamp: 'tpr 1/29/2018 11:03'!openFancyMailComposition: fancyMail	"FancyMailComposition should probably be removed in favour of MailComposition, but at least ought to be made a ToolBuilder thing"	^self subclassResponsibility! !!UIManager methodsFor: 'ui project indirecting' stamp: 'tpr 1/28/2018 17:50'!openPluggableFileList: aPluggableFileList label: aString in: aWorld	"PluggableFileList is being deprecated and this can go away soon"	^self subclassResponsibility! !!UIManager methodsFor: 'ui project indirecting' stamp: 'tpr 1/26/2018 18:37'!openSyntaxError: aSyntaxError	"Syntax error opening probably ought to be handled with a ToolBuilder dance instead of this"	^self subclassResponsibility! !!UIManager methodsFor: 'ui project indirecting' stamp: 'tpr 1/29/2018 20:26'!resumeDebugger: aDebugger process: aTopView	"resume a debugger - the two versions for mvc & morphic are very close and can surely be merged so that this can be removed"	^self subclassResponsibility! !!UIManager methodsFor: 'ui project indirecting' stamp: 'tpr 1/26/2018 18:17'!startUpMenu: aMenu withCaption: captionOrNil icon: aForm at: location allowKeyboard: aBoolean	"A menu needs to startup and depends on the current type of ui manager for what sort of startup to do. Very ugly, and really needs replacing with a much better menu system"		^self subclassResponsibility	! !!UIManager methodsFor: 'ui requests' stamp: 'ar 12/27/2004 10:44'!chooseFrom: aList	"Choose an item from the given list. Answer the index of the selected item."	^self chooseFrom: aList lines: #()! !!UIManager methodsFor: 'ui requests' stamp: 'ar 12/27/2004 10:45'!chooseFrom: aList lines: linesArray	"Choose an item from the given list. Answer the index of the selected item."	^self chooseFrom: aList lines: linesArray title: ''! !!UIManager methodsFor: 'ui requests' stamp: 'ar 12/27/2004 09:37'!chooseFrom: aList lines: linesArray title: aString	"Choose an item from the given list. Answer the index of the selected item."	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests' stamp: 'ar 12/27/2004 10:44'!chooseFrom: aList title: aString	"Choose an item from the given list. Answer the index of the selected item."	^self chooseFrom: aList lines: #() title: aString! !!UIManager methodsFor: 'ui requests' stamp: 'ar 7/15/2005 23:42'!chooseFrom: labelList values: valueList	"Choose an item from the given list. Answer the selected item."	^self chooseFrom: labelList values: valueList lines: #()! !!UIManager methodsFor: 'ui requests' stamp: 'ar 7/15/2005 23:43'!chooseFrom: labelList values: valueList lines: linesArray	"Choose an item from the given list. Answer the selected item."	^self chooseFrom: labelList values: valueList lines: linesArray title: ''! !!UIManager methodsFor: 'ui requests' stamp: 'ar 7/15/2005 23:43'!chooseFrom: labelList values: valueList lines: linesArray title: aString	"Choose an item from the given list. Answer the selected item."	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests' stamp: 'ar 7/15/2005 23:43'!chooseFrom: labelList values: valueList title: aString	"Choose an item from the given list. Answer the selected item."	^self chooseFrom: labelList values: valueList lines: #() title: aString! !!UIManager methodsFor: 'ui requests' stamp: 'eem 8/11/2017 10:27'!chooseFromOrAddTo: aList lines: linesArray title: aString	| index |	index := self chooseFrom: {'new...'}, aList lines: linesArray title: aString.	index = 0 ifTrue: [^ nil].		index = 1 ifTrue:		[^ self request: 'Please type new value' initialAnswer: ''].		^ aList at: index - 1! !!UIManager methodsFor: 'ui requests' stamp: 'mt 4/14/2015 14:56'!chooseMultipleFrom: aList	"Choose one or more items from the given list. Answer the indices of the selected items."		^ self chooseMultipleFrom: aList lines: #()! !!UIManager methodsFor: 'ui requests' stamp: 'mt 4/14/2015 14:55'!chooseMultipleFrom: aList lines: linesArray	"Choose one or more items from the given list. Answer the indices of the selected items."		^ self chooseMultipleFrom: aList lines: linesArray title: ''! !!UIManager methodsFor: 'ui requests' stamp: 'mt 4/14/2015 15:01'!chooseMultipleFrom: aList lines: linesArray title: aString	"Choose one or more items from the given list. Answer the indices of the selected items."		^ (self chooseFrom: aList lines: linesArray title: aString) in: [:result |		result = 0 ifTrue: [#()] ifFalse: [{result}]]! !!UIManager methodsFor: 'ui requests' stamp: 'mt 4/14/2015 14:56'!chooseMultipleFrom: aList title: aString	"Choose one or more items from the given list. Answer the indices of the selected items."		^self chooseMultipleFrom: aList lines: #() title: aString! !!UIManager methodsFor: 'ui requests' stamp: 'mt 4/14/2015 14:57'!chooseMultipleFrom: labelList values: valueList	"Choose one or more items from the given list. Answer the selected items."		^ self chooseMultipleFrom: labelList values: valueList lines: #()! !!UIManager methodsFor: 'ui requests' stamp: 'mt 4/14/2015 14:57'!chooseMultipleFrom: labelList values: valueList lines: linesArray	"Choose one or more items from the given list. Answer the selected items."		^ self chooseMultipleFrom: labelList values: valueList lines: linesArray title: ''! !!UIManager methodsFor: 'ui requests' stamp: 'mt 4/14/2015 15:02'!chooseMultipleFrom: labelList values: valueList lines: linesArray title: aString	"Choose one or more items from the given list. Answer the selected items."	^ (self chooseFrom: labelList values: valueList lines: linesArray title: aString)		ifNil: [#()]		ifNotNil: [:resultValue | {resultValue}]! !!UIManager methodsFor: 'ui requests' stamp: 'mt 4/14/2015 14:57'!chooseMultipleFrom: labelList values: valueList title: aString	"Choose one or more items from the given list. Answer the selected items."		^ self chooseMultipleFrom: labelList values: valueList lines: #() title: aString! !!UIManager methodsFor: 'ui requests' stamp: 'ar 12/27/2004 08:39'!confirm: queryString	"Put up a yes/no menu with caption queryString. Answer true if the 	response is yes, false if no. This is a modal question--the user must 	respond yes or no."	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests' stamp: 'ar 12/27/2004 09:49'!confirm: aString orCancel: cancelBlock	"Put up a yes/no/cancel menu with caption aString. Answer true if  	the response is yes, false if no. If cancel is chosen, evaluate  	cancelBlock. This is a modal question--the user must respond yes or no."	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests' stamp: 'dtl 3/29/2015 14:01'!confirm: aString orCancel: cancelBlock title: titleString	"Put up a yes/no/cancel menu with caption aString, and titleString to label the dialog.	Answer true if  the response is yes, false if no. If cancel is chosen, evaluate cancelBlock.	This is a modal question--the user must respond yes or no."	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests' stamp: 'dtl 3/29/2015 13:57'!confirm: queryString title: titleString	"Put up a yes/no menu with caption queryString, and titleString to label the dialog.	Answer true if the response is yes, false if no. This is a modal question--the user	must respond yes or no."	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests' stamp: 'dtl 3/29/2015 15:04'!confirm: queryString title: titleString trueChoice: trueChoice falseChoice: falseChoice	"Put up a yes/no menu with caption queryString, and titleString to label the dialog.	The actual wording for the two choices will be as provided in the trueChoice and	falseChoice parameters. Answer true if the response is the true-choice, false if it	is the false-choice. This is a modal question -- the user must respond one way or	the other."	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests' stamp: 'dc 1/10/2008 08:09'!confirm: queryString trueChoice: trueChoice falseChoice: falseChoice 	"Put up a yes/no menu with caption queryString. The actual wording for the two choices will be as provided in the trueChoice and falseChoice parameters. Answer true if the response is the true-choice, false if it's the false-choice.	This is a modal question -- the user must respond one way or the other."	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests' stamp: 'ar 12/27/2004 08:46'!inform: aString	"Display a message for the user to read and then dismiss"	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests - code' stamp: 'jr 2/2/2017 12:01'!chooseClassOrTrait	"Let the user choose a Class or Trait"		^self chooseClassOrTraitFrom: Smalltalk globals! !!UIManager methodsFor: 'ui requests - code' stamp: 'ul 12/12/2010 21:04'!chooseClassOrTrait: label	"Let the user choose a Class or Trait"		^self chooseClassOrTrait: label from: Smalltalk environment! !!UIManager methodsFor: 'ui requests - code' stamp: 'fbs 12/7/2013 16:58'!chooseClassOrTrait: label from: environment	"Let the user choose a Class or Trait."		| pattern |	pattern := self request: label.	^ self classOrTraitFrom: environment pattern: pattern label: label	! !!UIManager methodsFor: 'ui requests - code' stamp: 'jr 2/2/2017 12:01'!chooseClassOrTraitFrom: anEnvironment	"Let the user choose a Class or Trait from the given environment"		^self chooseClassOrTrait: 'Class name or fragment?' from: anEnvironment! !!UIManager methodsFor: 'ui requests - files' stamp: 'ar 7/16/2005 19:35'!chooseDirectory	"Let the user choose a directory"	^self chooseDirectoryFrom: FileDirectory default! !!UIManager methodsFor: 'ui requests - files' stamp: 'ar 7/16/2005 19:36'!chooseDirectory: label	"Let the user choose a directory"	^self chooseDirectory: label from: FileDirectory default! !!UIManager methodsFor: 'ui requests - files' stamp: 'ar 7/16/2005 19:36'!chooseDirectory: label from: dir	"Let the user choose a directory"	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests - files' stamp: 'ar 7/16/2005 19:36'!chooseDirectoryFrom: dir	"Let the user choose a directory"	^self chooseDirectory: nil from: dir! !!UIManager methodsFor: 'ui requests - files' stamp: 'ar 7/17/2005 00:26'!chooseFileMatching: patterns	"Let the user choose a file matching the given patterns"	^self chooseFileMatching: patterns label: nil! !!UIManager methodsFor: 'ui requests - files' stamp: 'ar 7/17/2005 00:26'!chooseFileMatching: patterns label: labelString	"Let the user choose a file matching the given patterns"	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests - files' stamp: 'tpr 12/22/2017 16:43'!chooseFileMatchingSuffixes: suffixList	"Let the user choose a file matching the given suffixes"	^self chooseFileMatchingSuffixes: suffixList label: nil! !!UIManager methodsFor: 'ui requests - files' stamp: 'tpr 12/22/2017 16:42'!chooseFileMatchingSuffixes: suffixList label: labelString	"Let the user choose a file matching the given suffixes"	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests - files' stamp: 'tpr 11/23/2017 13:30'!saveFilenameRequest: queryString initialAnswer: defaultAnswer 	"Open a FileSaverDialog to ask for a place and filename to use for saving a file. The initial suggestion for the filename is defaultAnswer but the user may choose any existing file or type in a new name entirely"	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests - progress' stamp: 'ar 2/28/2005 17:10'!displayProgress: titleString at: aPoint from: minVal to: maxVal during: workBlock	"Display titleString as a caption over a progress bar while workBlock is evaluated."	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests - progress' stamp: 'ar 2/28/2005 20:40'!informUser: aString during: aBlock	"Display a message above (or below if insufficient room) the cursor 	during execution of the given block.		UIManager default informUser: 'Just a sec!!' during: [(Delay forSeconds: 1) wait].	"	^self informUserDuring:[:bar| bar value: aString. aBlock value].! !!UIManager methodsFor: 'ui requests - progress' stamp: 'ar 2/28/2005 17:06'!informUserDuring: aBlock	"Display a message above (or below if insufficient room) the cursor 	during execution of the given block.		UIManager default informUserDuring:[:bar|			#(one two three) do:[:info|				bar value: info.				(Delay forSeconds: 1) wait]]"	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests - text' stamp: 'eem 8/11/2017 10:34'!chooseFont: titleString for: aModel setSelector: setSelector getSelector: getSelector	"Open a font-chooser for the given model"	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests - text' stamp: 'ar 7/16/2005 18:56'!edit: aText	"Open an editor on the given string/text"	^self edit: aText label: nil! !!UIManager methodsFor: 'ui requests - text' stamp: 'ar 7/16/2005 18:56'!edit: aText label: labelString	"Open an editor on the given string/text"	^self edit: aText label: labelString accept: nil! !!UIManager methodsFor: 'ui requests - text' stamp: 'ar 7/16/2005 18:56'!edit: aText label: labelString accept: anAction	"Open an editor on the given string/text"	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests - text' stamp: 'ar 2/28/2005 17:05'!multiLineRequest: queryString centerAt: aPoint initialAnswer: defaultAnswer answerHeight: answerHeight	"Create a multi-line instance of me whose question is queryString with	the given initial answer. Invoke it centered at the given point, and	answer the string the user accepts.  Answer nil if the user cancels.  An	empty string returned means that the ussr cleared the editing area and	then hit 'accept'.  Because multiple lines are invited, we ask that the user	use the ENTER key, or (in morphic anyway) hit the 'accept' button, to 	submit; that way, the return key can be typed to move to the next line."	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests - text' stamp: 'ar 12/27/2004 08:41'!request: queryString 	"Create an instance of me whose question is queryString. Invoke it 	centered at the cursor, and answer the string the user accepts. Answer 	the empty string if the user cancels."	^self request: queryString initialAnswer: ''! !!UIManager methodsFor: 'ui requests - text' stamp: 'ar 12/27/2004 08:41'!request: queryString initialAnswer: defaultAnswer 	"Create an instance of me whose question is queryString with the given 	initial answer. Invoke it centered at the given point, and answer the 	string the user accepts. Answer the empty string if the user cancels."	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests - text' stamp: 'dtl 2/12/2010 19:45'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint 	"Create an instance of me whose question is queryString with the given	initial answer. Invoke it centered at the given point, and answer the	string the user accepts. Answer the empty string if the user cancels."	^self subclassResponsibility! !!UIManager methodsFor: 'ui requests - text' stamp: 'ar 12/27/2004 08:47'!requestPassword: queryString	"Create an instance of me whose question is queryString. Invoke it centered	at the cursor, and answer the string the user accepts. Answer the empty 	string if the user cancels."	^self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UIManager class	instanceVariableNames: ''!!UIManager class methodsFor: 'class initialization' stamp: 'tpr 1/29/2018 11:41'!default	^ Project uiManager! !!UIManager class methodsFor: 'class initialization' stamp: 'nice 6/10/2017 17:39'!getDefault	"Ensure that a more specific manager can always be made by subclassing	a tool builder and implementing a more specific way of reacting to	#isActiveManager. For example, a BobsUIManager can subclass	MorphicUIManager and (if enabled, say Preferences useBobsUI) will	be considered before the parent (generic MorphicUIManager)."	^ (self allSubclasses		detect: [:any | any isActiveManager				and: [any subclasses						noneSatisfy: [:sub | sub isActiveManager]]]		ifNone: [])		ifNotNil: [:mgrClass | mgrClass new]! !!UIManager class methodsFor: 'class initialization' stamp: 'ar 2/11/2005 15:41'!isActiveManager	"Answer whether I should act as the active ui manager"	^false! !!UIManager class methodsFor: 'preferences' stamp: 'mt 8/16/2016 17:46'!openToolsAttachedToMouseCursor	<preference: 'Open Tools Attached to Mouse Cursor'		categoryList: #(Tools mouse)		description: 'If enabled, new tool windows will be attached to the mouse cursor to be positioned on screen with an additional click. Only occurs if a mouse event triggered that tool opening.'		type: #Boolean>	^ OpenToolsAttachedToMouseCursor ifNil: [false]! !!UIManager class methodsFor: 'preferences' stamp: 'mt 8/16/2016 17:46'!openToolsAttachedToMouseCursor: aBoolean	OpenToolsAttachedToMouseCursor := aBoolean.! !